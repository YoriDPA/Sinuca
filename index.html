<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Jogo de Sinuca Online</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            touch-action: none; /* Previne zoom e scroll no mobile */
        }
        canvas {
            background-color: #0d6b33;
            border-radius: 10px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2), 0 6px 6px rgba(0,0,0,0.25);
            cursor: crosshair;
        }
        .wood-texture {
             background-color: #6B4226;
             background-image:
               repeating-linear-gradient(45deg, rgba(255,255,255,0.05) 0, rgba(255,255,255,0.05) 5px, transparent 5px, transparent 10px),
               repeating-linear-gradient(-45deg, rgba(255,255,255,0.05) 0, rgba(255,255,255,0.05) 5px, transparent 5px, transparent 10px);
        }
        .player-info-active {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.7);
        }
        .ball-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: black;
            background-color: white;
            border: 1px solid #ccc;
            position: relative;
            overflow: hidden;
        }
        .ball-icon .stripe {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 60%;
            transform: translateY(-50%);
            background-color: inherit;
        }
         .ball-icon span {
            position: relative;
            z-index: 1;
            background-color: white;
            border-radius: 50%;
            width: 60%;
            height: 60%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #lobby, #gameContainer {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body class="bg-gray-800 flex flex-col items-center justify-center min-h-screen p-4 text-white">

    <!-- Tela de Lobby -->
    <div id="lobby" class="w-full max-w-md mx-auto text-center">
        <h1 class="text-4xl font-bold tracking-tight mb-4">Sinuca Online</h1>
        <p class="text-gray-400 mb-6">Crie um jogo para desafiar um amigo ou entre em um jogo existente.</p>
        <div class="bg-gray-900/50 p-6 rounded-lg shadow-xl">
            <button id="createGameBtn" class="w-full bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-6 rounded-lg shadow-md transition-transform transform hover:scale-105 mb-4" disabled>
                Criar Novo Jogo
            </button>
            <div class="border-t border-gray-700 my-4"></div>
            <h2 class="text-lg font-semibold mb-2">Entrar em um Jogo</h2>
            <input type="text" id="gameIdInput" placeholder="Cole o ID do Jogo aqui" class="w-full bg-gray-700 text-white placeholder-gray-400 p-3 rounded-lg border-2 border-gray-600 focus:border-indigo-500 focus:outline-none mb-2 text-center" disabled>
            <button id="joinGameBtn" class="w-full bg-emerald-600 hover:bg-emerald-500 text-white font-bold py-3 px-6 rounded-lg shadow-md transition-transform transform hover:scale-105" disabled>
                Entrar
            </button>
        </div>
        <p class="text-xs text-gray-500 mt-4">Seu ID de Usuário: <span id="userIdDisplay" class="font-mono">A ligar...</span></p>
    </div>

    <!-- Tela do Jogo -->
    <div id="gameContainer" class="w-full max-w-7xl mx-auto flex-col items-center hidden">
        <div class="mb-2 text-center">
            <h1 class="text-3xl font-bold tracking-tight">Sinuca Clássica</h1>
            <p id="status" class="text-lg text-gray-300 h-7">A carregar...</p>
        </div>
        
        <div class="w-full flex justify-center items-start gap-4">
             <div id="player1-panel" class="p-3 bg-gray-900/50 rounded-lg w-48 text-center border-2 border-transparent transition-all mt-8"></div>
            <div class="flex-1 flex flex-col items-center max-w-5xl">
                <div class="flex w-full justify-center items-stretch gap-4">
                    <div id="powerBarContainer" class="w-8 bg-gray-900/50 rounded-lg p-1 flex-col-reverse shadow-inner hidden">
                        <div id="powerBar" class="bg-gradient-to-t from-yellow-400 via-orange-500 to-red-600 w-full rounded-sm" style="height: 0%; transition: height 0.05s;"></div>
                    </div>
                    <div class="aspect-[2/1] w-full wood-texture p-4 rounded-xl shadow-2xl flex-1">
                        <canvas id="poolCanvas"></canvas>
                    </div>
                </div>
            </div>
            <div id="player2-panel" class="p-3 bg-gray-900/50 rounded-lg w-48 text-center border-2 border-transparent transition-all mt-8"></div>
        </div>

        <div class="mt-4 flex justify-center items-center space-x-4">
             <p class="text-xs text-gray-400">ID do Jogo: <span id="gameIdDisplay" class="font-mono bg-gray-700 px-2 py-1 rounded cursor-pointer" title="Clique para copiar"></span></p>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc, collection } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = {
          apiKey: "AIzaSyBBjOGPIyQMtoMl7BQEtDRjSIQPtnesZdo",
          authDomain: "sinuca-c6a5b.firebaseapp.com",
          projectId: "sinuca-c6a5b",
          storageBucket: "sinuca-c6a5b.appspot.com",
          messagingSenderId: "306713375189",
          appId: "1:306713375189:web:00f51e1ead8e2e67520d5c",
          measurementId: "G-2Q1D0E09D7"
        };
        
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-pool-app';
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        const lobby = document.getElementById('lobby');
        const gameContainer = document.getElementById('gameContainer');
        const createGameBtn = document.getElementById('createGameBtn');
        const joinGameBtn = document.getElementById('joinGameBtn');
        const gameIdInput = document.getElementById('gameIdInput');
        const userIdDisplay = document.getElementById('userIdDisplay');
        const gameIdDisplay = document.getElementById('gameIdDisplay');
        const canvas = document.getElementById('poolCanvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        const powerBarContainer = document.getElementById('powerBarContainer');
        const powerBar = document.getElementById('powerBar');
        const p1Panel = document.getElementById('player1-panel');
        const p2Panel = document.getElementById('player2-panel');

        let table, localBalls = [], cueBall, gameState;
        let mouse = { x: 0, y: 0, down: false, power: 0 };
        let shotTaken = false;
        let unsubscribeGame;
        let currentUserId = null;
        let playerNumber = null;
        let currentGameId = null;
        let localSimulation = false;

        const BALL_RADIUS = 12;
        const POCKET_RADIUS = 20;
        const FRICTION = 0.985;
        const BORDER_WIDTH = 25;
        const MAX_POWER_PULL = 150;
        const MAX_SHOT_VELOCITY = 25;
        const BALL_COLORS = {
            0: { fill: '#ffffff', stroke: '#d4d4d4' }, 1: { fill: '#facc15', stroke: '#ca8a04' },
            2: { fill: '#3b82f6', stroke: '#1d4ed8' }, 3: { fill: '#ef4444', stroke: '#b91c1c' },
            4: { fill: '#8b5cf6', stroke: '#5b21b6' }, 5: { fill: '#f97316', stroke: '#c2410c' },
            6: { fill: '#16a34a', stroke: '#14532d' }, 7: { fill: '#78350f', stroke: '#451a03' },
            8: { fill: '#171717', stroke: '#000000' }, 9: { fill: '#facc15', stroke: '#ca8a04' },
            10: { fill: '#3b82f6', stroke: '#1d4ed8' }, 11: { fill: '#ef4444', stroke: '#b91c1c' },
            12: { fill: '#8b5cf6', stroke: '#5b21b6' }, 13: { fill: '#f97316', stroke: '#c2410c' },
            14: { fill: '#16a34a', stroke: '#14532d' }, 15: { fill: '#78350f', stroke: '#451a03' },
        };

        class Vector {
            constructor(x, y) { this.x = x; this.y = y; }
            add(v) { return new Vector(this.x + v.x, this.y + v.y); }
            subtract(v) { return new Vector(this.x - v.x, this.y - v.y); }
            multiply(s) { return new Vector(this.x * s, this.y * s); }
            dot(v) { return this.x * v.x + this.y * v.y; }
            magnitude() { return Math.sqrt(this.x ** 2 + this.y ** 2); }
            normalize() { const mag = this.magnitude(); return mag === 0 ? new Vector(0, 0) : new Vector(this.x / mag, this.y / mag); }
        }

        class Ball {
            constructor(x, y, number) {
                this.pos = new Vector(x, y);
                this.vel = new Vector(0, 0);
                this.number = number;
                this.radius = BALL_RADIUS;
                this.mass = 1;
                this.isPocketed = false;
            }
            draw() {
                if (this.isPocketed) return;
                const color = BALL_COLORS[this.number];
                ctx.beginPath();
                ctx.arc(this.pos.x + 2, this.pos.y + 2, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.fill();
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = color.fill;
                ctx.fill();
                if (this.number > 8) {
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, this.radius, -0.25 * Math.PI, 0.25 * Math.PI, false);
                    ctx.arc(this.pos.x, this.pos.y, this.radius, 0.75 * Math.PI, 1.25 * Math.PI, false);
                    ctx.fill();
                }
                ctx.strokeStyle = color.stroke;
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(this.pos.x - this.radius * 0.4, this.pos.y - this.radius * 0.4, this.radius * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.fill();
                if (this.number > 0) {
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, this.radius * 0.6, 0, Math.PI * 2);
                    ctx.fillStyle = 'white';
                    ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.font = 'bold 10px Inter';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.number, this.pos.x, this.pos.y);
                }
            }
        }

        function getInitialGameState(p1Id) {
            const initialBallPositions = getInitialBallPositions(); 
            return {
                balls: initialBallPositions.map(b => ({
                    pos: b.pos, 
                    vel: {x: 0, y: 0},
                    number: b.number,
                    isPocketed: false
                })),
                gameState: {
                    currentPlayer: 1,
                    players: {
                        1: { id: p1Id, name: 'Jogador 1', type: null, balls: [] },
                        2: { id: null, name: 'A aguardar...', type: null, balls: [] }
                    },
                    ballTypesAssigned: false,
                    gameOver: false,
                    winner: null,
                    ballsPocketedThisTurn: [],
                }
            };
        }
        
        async function createGame() {
            const gameId = Math.floor(1000 + Math.random() * 9000).toString();
            currentGameId = gameId;
            playerNumber = 1;
            const initialState = getInitialGameState(currentUserId);
            const gameRef = doc(db, `artifacts/${appId}/public/data/poolGames`, gameId);
            await setDoc(gameRef, initialState);
            joinGame(gameId);
        }

        async function joinGame(gameId) {
            if (!gameId) { alert("Por favor, insira um ID de jogo."); return; }
            const gameRef = doc(db, `artifacts/${appId}/public/data/poolGames`, gameId);
            const gameSnap = await getDoc(gameRef);
            if (!gameSnap.exists()) { alert("Jogo não encontrado!"); return; }

            const gameData = gameSnap.data();
            if (gameData.gameState.players[1].id === currentUserId) {
                playerNumber = 1;
            } else if (!gameData.gameState.players[2].id) {
                playerNumber = 2;
                await updateDoc(gameRef, { 'gameState.players.2.id': currentUserId, 'gameState.players.2.name': 'Jogador 2' });
            } else if (gameData.gameState.players[2].id === currentUserId) {
                playerNumber = 2;
            } else { alert("O jogo já está cheio!"); return; }
            
            currentGameId = gameId;
            lobby.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            gameIdDisplay.textContent = gameId;
            
            setupTable(); 

            if (unsubscribeGame) unsubscribeGame();
            unsubscribeGame = onSnapshot(gameRef, (doc) => {
                const data = doc.data();
                if (!data || localSimulation) return;
                updateLocalState(data);
            });
        }
        
        function updateLocalState(serverState) {
            if (!table) return;
            localBalls = serverState.balls.map(b => {
                const absoluteX = b.pos.x * table.width;
                const absoluteY = b.pos.y * table.height;
                const ball = new Ball(absoluteX, absoluteY, b.number);
                ball.vel = new Vector(b.vel.x, b.vel.y);
                ball.isPocketed = b.isPocketed;
                return ball;
            });
            cueBall = localBalls.find(b => b.number === 0);
            gameState = serverState.gameState;
            requestAnimationFrame(drawGame);
        }
        
        function drawGame() {
            if (!table || !gameState) return;
            ctx.clearRect(0, 0, table.width, table.height);
            updateUI();
            drawTable();
            localBalls.forEach(b => b.draw());
            const isMyTurn = gameState.players[gameState.currentPlayer].id === currentUserId;
            if (isMyTurn && !checkBallsMoving(localBalls) && !cueBall?.isPocketed) {
                drawCue();
            }
        }
        
        async function takeShot(power, direction) {
            if (!cueBall) return;
            shotTaken = true;
            localSimulation = true;
            
            cueBall.vel = direction.multiply(power);

            const runSimulation = () => {
                if (checkBallsMoving(localBalls)) {
                    handleCollisions(localBalls, table);
                    localBalls.forEach(b => {
                        b.pos = b.pos.add(b.vel);
                        b.vel = b.vel.multiply(FRICTION);
                        if (b.vel.magnitude() < 0.05) b.vel = new Vector(0,0);
                    });
                    requestAnimationFrame(() => { drawGame(); runSimulation(); });
                } else {
                    analyzeTurnResults();
                    const finalBallsState = localBalls.map(b => ({
                        pos: { x: b.pos.x / table.width, y: b.pos.y / table.height }, 
                        vel: { x: 0, y: 0 },
                        number: b.number, isPocketed: b.isPocketed
                    }));
                    const gameRef = doc(db, `artifacts/${appId}/public/data/poolGames`, currentGameId);
                    updateDoc(gameRef, { balls: finalBallsState, gameState: gameState }).then(() => {
                        shotTaken = false;
                        localSimulation = false;
                    });
                }
            };
            runSimulation();
        }

        function setupTable() {
            const parent = canvas.parentElement;
            const aspectRatio = 2;
            const parentWidth = parent.clientWidth;
            const parentHeight = parent.clientHeight;
            let newWidth, newHeight;
            if (parentWidth / parentHeight > aspectRatio) {
                newHeight = parentHeight; newWidth = newHeight * aspectRatio;
            } else {
                newWidth = parentWidth; newHeight = newWidth / aspectRatio;
            }
            canvas.width = newWidth; canvas.height = newHeight;
            table = {
                width: canvas.width, height: canvas.height, border: BORDER_WIDTH,
                pockets: [
                    { x: BORDER_WIDTH, y: BORDER_WIDTH }, { x: canvas.width / 2, y: BORDER_WIDTH - 5 }, { x: canvas.width - BORDER_WIDTH, y: BORDER_WIDTH },
                    { x: BORDER_WIDTH, y: canvas.height - BORDER_WIDTH }, { x: canvas.width / 2, y: canvas.height - BORDER_WIDTH + 5 }, { x: canvas.width - BORDER_WIDTH, y: canvas.height - BORDER_WIDTH },
                ]
            };
        }

        function getInitialBallPositions() {
            let positions = [];
            const ballRadiusRatioX = BALL_RADIUS / (1000); 
            const ballRadiusRatioY = BALL_RADIUS / (500);  
            
            positions.push({ pos: { x: 0.25, y: 0.5 }, number: 0 });

            const ballNumbers = [1, 10, 2, 12, 3, 14, 4, 15, 5, 9, 6, 11, 7, 13].sort(() => Math.random() - 0.5);
            let currentBall = 0;

            const startXRatio = 0.7;
            const startYRatio = 0.5;

            for (let i = 0; i < 5; i++) {
                for (let j = 0; j <= i; j++) {
                    const x = startXRatio + i * (ballRadiusRatioX * 2 * 0.866);
                    const y = startYRatio + j * (ballRadiusRatioY * 2) - i * ballRadiusRatioY;
                    let number;
                    if (i === 2 && j === 1) { number = 8; }
                    else { number = ballNumbers[currentBall++]; }

                    if (number !== undefined) {
                        positions.push({ pos: { x: x, y: y }, number: number });
                    }
                }
            }
            return positions;
        }

        function drawTable() {
            ctx.fillStyle = '#0a5429';
            ctx.fillRect(BORDER_WIDTH, BORDER_WIDTH, table.width - BORDER_WIDTH * 2, table.height - BORDER_WIDTH * 2);
            table.pockets.forEach(pocket => {
                ctx.beginPath(); ctx.arc(pocket.x, pocket.y, POCKET_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = 'black'; ctx.fill();
            });
        }
        
        function checkBallsMoving(balls) { return balls.some(b => !b.isPocketed && b.vel.magnitude() > 0.05); }

        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return { x: (evt.clientX - rect.left) * scaleX, y: (evt.clientY - rect.top) * scaleY };
        }

        function handlePointerDown(e) {
            if (localSimulation || !gameState) return;
            const isMyTurn = gameState.players[gameState.currentPlayer].id === currentUserId;
            if (!isMyTurn || checkBallsMoving(localBalls) || (cueBall && cueBall.isPocketed)) return;
            mouse.down = true;
            powerBarContainer.style.display = 'flex';
        }

        function handlePointerUp(e) {
            if (!mouse.down) return;
            mouse.down = false;
            powerBarContainer.style.display = 'none';
            powerBar.style.height = '0%';
            const powerRatio = Math.min(mouse.power / MAX_POWER_PULL, 1);
            const finalPower = powerRatio * MAX_SHOT_VELOCITY;
            const dir = cueBall.pos.subtract(new Vector(mouse.x, mouse.y)).normalize();
            if (finalPower > 0.1) {
                takeShot(finalPower, dir);
            }
            mouse.power = 0;
        }

        function handlePointerMove(e) {
            const pos = getMousePos(e);
            mouse.x = pos.x; mouse.y = pos.y;
            if (mouse.down) {
                const dist = cueBall.pos.subtract(new Vector(mouse.x, mouse.y)).magnitude();
                mouse.power = Math.max(0, dist - BALL_RADIUS);
                const powerPercent = Math.min(mouse.power / MAX_POWER_PULL * 100, 100);
                powerBar.style.height = `${powerPercent}%`;
            }
        }
        
        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUserId = user.uid;
                userIdDisplay.textContent = currentUserId;
                createGameBtn.disabled = false;
                joinGameBtn.disabled = false;
                gameIdInput.disabled = false;

                createGameBtn.addEventListener('click', createGame);
                joinGameBtn.addEventListener('click', () => joinGame(gameIdInput.value.trim()));
                gameIdDisplay.addEventListener('click', () => {
                    navigator.clipboard.writeText(currentGameId).then(() => alert('ID do Jogo copiado!'));
                });

                // Eventos de Rato
                canvas.addEventListener('mousedown', handlePointerDown);
                window.addEventListener('mouseup', handlePointerUp);
                window.addEventListener('mousemove', handlePointerMove);
                
                // Eventos de Toque
                canvas.addEventListener('touchstart', (e) => { 
                    e.preventDefault(); 
                    handlePointerDown(e.touches[0]); 
                }, { passive: false });
                
                window.addEventListener('touchend', (e) => { 
                    if (mouse.down) {
                        e.preventDefault(); 
                        handlePointerUp(e.changedTouches[0]); 
                    }
                }, { passive: false });

                window.addEventListener('touchmove', (e) => { 
                    if (mouse.down) {
                        e.preventDefault(); 
                        handlePointerMove(e.touches[0]); 
                    }
                }, { passive: false });


                window.addEventListener('resize', () => { 
                    if(currentGameId) { 
                        setupTable(); 
                        // Força a atualização do estado local para recalcular as posições das bolas
                        updateLocalState({ balls: gameState.balls, gameState: gameState }); 
                    } 
                });
            } else {
                signInAnonymously(auth);
            }
        });
        
        function updateUI() {
            if (!gameState) return;
            const { currentPlayer, players, gameOver, winner } = gameState;
            const player1 = players[1] || {};
            const player2 = players[2] || {};
            
            const renderPlayerPanel = (panel, player, playerNum) => {
                panel.innerHTML = '';
                panel.classList.toggle('player-info-active', currentPlayer === playerNum && !gameOver);
                let name = player.name || `Jogador ${playerNum}`;
                if (player.id === currentUserId) name += " (Você)";

                const typeText = player.type ? (player.type === 'solids' ? 'Bolas Lisas (1-7)' : 'Bolas Listradas (9-15)') : 'A aguardar...';

                panel.innerHTML = `
                    <h2 class="font-bold text-lg">${name}</h2>
                    <p class="text-sm text-blue-300 h-5">${typeText}</p>
                    <div class="flex flex-wrap gap-1 mt-2 justify-center min-h-[52px]">
                        ${(player.balls || []).sort((a,b)=>a-b).map(b => {
                            const color = BALL_COLORS[b];
                            return `<div class="ball-icon" style="background-color: ${color.fill};">
                                ${b > 8 ? `<div class="stripe"></div>` : ''}
                                <span>${b}</span>
                            </div>`
                        }).join('')}
                    </div>
                `;
            };

            renderPlayerPanel(p1Panel, player1, 1);
            renderPlayerPanel(p2Panel, player2, 2);

            if (gameOver) {
                statusEl.textContent = `${winner.name} venceu o jogo!`;
            } else if (players[2] && players[2].id) {
                const player = players[currentPlayer];
                let turnInfo = `${player.name}, a sua vez.`;
                statusEl.textContent = turnInfo;
            } else {
                statusEl.textContent = "A aguardar oponente...";
            }
        }

        function handleCollisions(balls, table) {
             for (let i = 0; i < balls.length; i++) {
                const b1 = balls[i];
                if (b1.isPocketed) continue;
                if (b1.pos.x - b1.radius <= table.border) { b1.vel.x *= -1; b1.pos.x = b1.radius + table.border; }
                if (b1.pos.x + b1.radius >= table.width - table.border) { b1.vel.x *= -1; b1.pos.x = table.width - b1.radius - table.border; }
                if (b1.pos.y - b1.radius <= table.border) { b1.vel.y *= -1; b1.pos.y = b1.radius + table.border; }
                if (b1.pos.y + b1.radius >= table.height - table.border) { b1.vel.y *= -1; b1.pos.y = table.height - b1.radius - table.border; }
                for (let j = i + 1; j < balls.length; j++) {
                    const b2 = balls[j];
                    if (b2.isPocketed) continue;
                    const distVec = b1.pos.subtract(b2.pos);
                    const dist = distVec.magnitude();
                    if (dist < b1.radius + b2.radius) {
                        const overlap = (b1.radius + b2.radius - dist) / 2;
                        const correction = distVec.normalize().multiply(overlap);
                        b1.pos = b1.pos.add(correction); b2.pos = b2.pos.subtract(correction);
                        const normal = b1.pos.subtract(b2.pos).normalize();
                        const tangent = new Vector(-normal.y, normal.x);
                        const v1n = b1.vel.dot(normal); const v1t = b1.vel.dot(tangent);
                        const v2n = b2.vel.dot(normal); const v2t = b2.vel.dot(tangent);
                        b1.vel = normal.multiply(v2n).add(tangent.multiply(v1t));
                        b2.vel = normal.multiply(v1n).add(tangent.multiply(v2t));
                    }
                }
                for (const pocket of table.pockets) {
                    const distToPocket = b1.pos.subtract(new Vector(pocket.x, pocket.y)).magnitude();
                    if (distToPocket < POCKET_RADIUS && !b1.isPocketed) {
                        b1.isPocketed = true; b1.vel = new Vector(0,0);
                        if (!gameState.ballsPocketedThisTurn.includes(b1.number)) {
                             gameState.ballsPocketedThisTurn.push(b1.number);
                        }
                    }
                }
            }
        }
        function analyzeTurnResults() {
            const { players } = gameState;
            const pocketed = gameState.ballsPocketedThisTurn;
            let foul = false;
            let legitimatePocket = false;
            const currentPlayer = players[gameState.currentPlayer];
            const opponent = players[gameState.currentPlayer === 1 ? 2 : 1];

            if (pocketed.includes(0)) {
                foul = true;
                const cueBallRef = localBalls.find(b => b.number === 0);
                if (cueBallRef) {
                    cueBallRef.pos = new Vector(table.width * 0.25, table.height * 0.5);
                    cueBallRef.isPocketed = false;
                }
            }

            if (pocketed.includes(8)) {
                const allPlayerBallsPocketed = (currentPlayer.type === 'solids' && currentPlayer.balls.length === 7) || (currentPlayer.type === 'stripes' && currentPlayer.balls.length === 7);
                if (allPlayerBallsPocketed && !foul) {
                    gameState.gameOver = true; gameState.winner = currentPlayer;
                } else {
                    gameState.gameOver = true; gameState.winner = opponent;
                }
                gameState.ballsPocketedThisTurn = []; return;
            }

            for (const ballNum of pocketed) {
                if (ballNum === 0 || ballNum === 8) continue;
                const ballType = (ballNum >= 1 && ballNum <= 7) ? 'solids' : 'stripes';
                if (!gameState.ballTypesAssigned) {
                    currentPlayer.type = ballType;
                    opponent.type = (ballType === 'solids' ? 'stripes' : 'solids');
                    gameState.ballTypesAssigned = true;
                }
                if (players[1].type === ballType) {
                    if (!players[1].balls.includes(ballNum)) players[1].balls.push(ballNum);
                } else if(players[2].type === ballType) {
                    if (!players[2].balls.includes(ballNum)) players[2].balls.push(ballNum);
                }
                if (currentPlayer.type === ballType) {
                    legitimatePocket = true;
                }
            }

            if (pocketed.length === 0 || foul || !legitimatePocket) {
                gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
            }
            gameState.ballsPocketedThisTurn = [];
        }
        function drawCue() {
            if(!cueBall || cueBall.isPocketed) return;
            const aimDir = new Vector(mouse.x, mouse.y).subtract(cueBall.pos).normalize();
            let firstHit = { ball: null, dist: Infinity };
            for (const ball of localBalls) {
                if (ball === cueBall || ball.isPocketed) continue;
                const oc = ball.pos.subtract(cueBall.pos);
                const tca = oc.dot(aimDir); if (tca <= 0) continue;
                const d2 = oc.dot(oc) - tca * tca;
                const collisionRadius = cueBall.radius + ball.radius;
                if (d2 >= collisionRadius * collisionRadius) continue;
                const thc = Math.sqrt(collisionRadius * collisionRadius - d2);
                const t0 = tca - thc;
                if (t0 > 0 && t0 < firstHit.dist) { firstHit = { ball: ball, dist: t0 }; }
            }
            const lineEnd = firstHit.ball ? cueBall.pos.add(aimDir.multiply(firstHit.dist)) : cueBall.pos.add(aimDir.multiply(table.width));
            ctx.beginPath();
            ctx.moveTo(cueBall.pos.x, cueBall.pos.y);
            ctx.lineTo(lineEnd.x, lineEnd.y);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.setLineDash([5, 10]);
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.setLineDash([]);
            if (firstHit.ball) {
                const targetBall = firstHit.ball;
                const cueCollisionPos = cueBall.pos.add(aimDir.multiply(firstHit.dist));
                const targetDir = targetBall.pos.subtract(cueCollisionPos).normalize();
                ctx.beginPath();
                ctx.moveTo(targetBall.pos.x, targetBall.pos.y);
                ctx.lineTo(targetBall.pos.x + targetDir.x * table.width, targetBall.pos.y + targetDir.y * table.height);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cueCollisionPos.x, cueCollisionPos.y, cueBall.radius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.setLineDash([2, 4]);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            const cueLength = 250;
            const powerOffset = (mouse.power / MAX_POWER_PULL) * 60;
            const startX = cueBall.pos.x - aimDir.x * (20 + powerOffset);
            const startY = cueBall.pos.y - aimDir.y * (20 + powerOffset);
            const endX = startX - aimDir.x * cueLength;
            const endY = startY - aimDir.y * cueLength;
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
            gradient.addColorStop(0, "#c8a165"); 
            gradient.addColorStop(0.8, "#875f3e");
            gradient.addColorStop(1, "#3a2a1a"); 
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(startX - aimDir.x*10, startY - aimDir.y*10);
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 8;
            ctx.stroke();
        }

    </script>
</body>
</html>
